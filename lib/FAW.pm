package Dancer::Plugin::FAW;

use strict;
use warnings;

use Dancer ':syntax';
use Dancer::Plugin;
use Dancer::Plugin::uRBAC;

use FAW::Form;
use Validate::Tiny qw(validate);
use Data::Dump qw(dump);

=encoding utf-8

=cut

=head1 NAME

Dancer::Plugin::FAW - Form Advanced Way

=head1 VERSION

0.2

=cut

our $VERSION = '0.2';

=head1 SYNOPSIS

После подключения модуля мы можем декларировать формы в описательном виде в
коде программы. Преимущество подхода: возможность быстрого переопределения
полей формы, логики работы с полями, проверок полей и отображения полей в БД
в одном месте.

Задекларируйте описание новой формы

    fawform '/callback' => {
        template    => 'callback-form',
        redirect    => '',
        layout      => '',
        formname    => '',
        fields      => [ 
            { ... },
        ],
        buttons     => [
            { ... },
        ],
        before      => sub {
            ...
        },
        after       => sub {
            ...
        },
    };

Расширьте поля формы в разделе fields и кнопки формы в разделе buttons, как это
описано в FAW::Forms.

Если это необходимо, определите логику работы формы перед её отрисовкой
(before): здесь можно управлять правами, реализовывать подстановку дефолтных значений 
в поля формы.

Определите логику работы формы после отправки данных (after): куда и каким образом
будут помещены данные; куда будет совершён переход (если он отличается от
заданного в поле redirect в зависимости от условий формы); какие дополнительные
действия должна выполнить логика в том или ином случае.

=cut 

=head1 DESCRIPTION

Модуль для продвинутого описания форм. Склеивает FAW::Forms и Dancer с
удобными дополнениями.

=cut

=head2 fawConvertPath 
    
Одна из основных задач - преобразовать точку общего вида к частному, то есть
выполнить замену и подстановку поледержателей на значения поледержателей.

=cut 

sub fawConvertPath {
    my $t = $_[0];
    $t =~ s/:url/$_[1]/;
    return $t;
};

=head2 fawform 

Через описание формы передаётся ряд дополнительных параметров для fawform:
    
- template = шаблон, использующийся для вывода формы. Отрисовка формы ведётся
через этот шаблон;

- redirect = на какую страничку перейти в случае принятия данных формы.

Перенаправление можно указать явно в хэше $faw или в хэше config или не
указывать, и перейти к корневой точке (путь "/" = индексная страничка).

=cut

register fawform => sub {
    my ($path, $config) = @_;
    my $url;
    my $z;
    my $results;
    my $redirect;
    
=text

- layout = особый макет, который может быть переопределён вместо стандартного
макета для вывода формы. Стандартный макет задаётся в конфигурационном файле с
помощью директивы layout.

Параметр "action" становится необязательным (задаёт точку сайта, на которую 
будут передаваться данные формы), поскольку он автоматически подставляется
при вызове методов get/post.

=cut

    $config->{layout} ||= config->{layout};
    $config->{action} = prefix . $path;

    my $faw = FAW::Form->new($config);
    
=text

Если вызов формы выполнялся с помощью запроса GET,
то это значит, что эта форма новая, и действий над данными 
(изменение полей) не производилось.

При настройке формы можно указать своё действие для варианта GET, а можно
использовать общую точку before.

Во втором случае мы выполняем пользовательское действие before до отрисовки
шаблона и вызываем пользовательское действие after после его отрисовки.

Внимание! первый параметр для действия и before и after - тип запроса GET/POST.

А вот второй параметр зависит от типа действия. В случае before - это хэш на
обработчик формы, модуль FAW::Form. Это делается для того, чтобы в действии
before можно было изменить логику работы, обработать или сопоставить данные и
т.п. В случае же GET after - это шаблон, а в случае POST after - тоже ссылка на
FAW::Form.

=cut

    if ($config->{get}) {
        get $path => $config->{get};
    } else {
        get $path => sub {
            &{$config->{before}}("get", \$faw) if defined($config->{before});
            $z = template $config->{template}, { form => $faw }, { layout => $config->{layout} };
            &{$config->{after}}("get", \$z) if defined($config->{after});
            return $z;
        };
    };
    
=text 

Такое поведение объясняется очень просто. Для процедуры GET after логика работы
не важна, но нам может потребоваться изменение шаблона. А вот в случае POST
after нам крайне важно иметь возможность управлять поведением формы, в
частности, её переходами.

Поэтому стандартный обработчик POST несколько сложнее, чем GET.

=cut

    if ($config->{post}) {
        post $path => $config->{post};
    } else {
        post $path => sub {

=text

Для начала нам следует сопоставить полученные на предыдущем этапе данные в поля
формы - вдруг, мы передумаем переходить куда-либо, и потребуем у пользователя
поправить себя.

Затем нам следует выполнить валидацию данных пользователя, основываясь на
правилах секции validate описания формы и используя модуль validate.

И только после этого мы можем вызвать предопределённое действие before POST
(если, конечно, оно было предопределено).

=cut

            $faw->map_params(params);
            $results = validate(params, $config->{validate}) if defined($config->{validate}) || 0;
            
=text

Дальнейшее поведение сильно зависит от того, была ли успешной встроенная
валидация. Если это так, то мы со спокойной совестью передаём данные в
обработчик after POST (чтобы их можно было вставить в БД) и выполняем переход
в заранее определённую точку (но только если обработчик after POST) вернул
статус успешного действия (1 на выходе). Иначе - адЪ, мы не имеем права уйти из
формы. Вдруг, там ошибка - база отвалилась или что ещё произошло...

Кстати, выход из формы определяется параметром redirect в настройках формы. А
вот параметр action в самой форме отвечает за то, куда должны передаваться
данные формы для валидации и обязан совпадать с текущим путём формы. 

Действие post может вернуть не только статус "успех" (когда первый параметр =
1), но и точку возврата - это особенно удобно, если точка возврата зависит от
содержимого и должна вычисляться в процессе работы процедуры.

=cut

            if (! defined($config->{validate}) || ($results->{success} == 1)) {
                $results = 0;
                if ( defined($config->{before}) ) {
                    ( $results, $redirect ) = &{$config->{before}}("post", \$faw);
                    $results ||= 0;
                }
                if ($results == 1) {
                    my $z = $redirect || $config->{redirect} || "/";
                    redirect $z;
                }
            }

=text

... и мы должны вернуться к форме, отрисовать её и сообщить об этой ошибке. 

То есть, мы рендерим шаблон и возвращаемся к нормальной (штатной) работе с
формой.

=cut

            $z = template $config->{template}, { form => $faw }, { layout => $config->{layout} };
            &{$config->{after}}("post", \$z) if defined($config->{after});
            return $z;
        };
    };

};

=text

Со стороны разработчика в наиболее типичном случае остаётся 
воспользоваться модулем следующим образом:

- определить поля формы согласно FAW::Form и FAW::Elements;

- определить кнопки формы согласно FAW::Form и FAW::Elements;

- описать правило before GET при вхождении в форму (сопоставление имеющихся
данных и полей формы);

- описать правило before POST для выхода из формы (сохранение данных или
дополнительные действия с обязательным подтверждением успешности);

=cut

register_plugin;

1;
